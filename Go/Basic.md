## 변수
* 변수는 Go 언어의 키워드인 ```var```를 사용하여 선언한다  
    * var 키워드 뒤에 변수명을 적고, 그뒤에 변수타입을 적는다

아래코드는 a라는 정수형 변수를 Go언어로 선언한 것이다
```Go
var a int
```
* 변수 선언문에서 변수 초기값을 할당할 수도 있다  

아래코드는 float32타입의 변수 f에 11.0이라는 초기값을 할당하며 변수를 선언한 것이다
```Go
var f flaot32 = 11
```

* 만약 선언된 변수가 Go 프로그램 내에서 사용되지 않는다면 에러를 발생시킨다
    * 사용되지 않는 변수는 프로그램에서 삭제하자

아래코드처럼 동일한 타입의 변수가 복수 개 있을경우 변수들을 나열하고 마지막에 타입을 한번만 지정하면된다
```Go
var i, j, k int
```

* 복수 변수들이 선언된 상황에서 초기값을 지정할수 있다, 초기값은 순서대로 변수에 할당된다

아래코드는 i는1, j는2, k는3 이 할당된다
```Go
var i, j, k int = 1, 2, 3
```

* 변수를 선언하면서 초기값을 지정하지 않으면 Go는 ```Zero Value```를 기본적으로 할당함
    * 숫자형은 0, bool 타입은 false, string형에는 ""(빈문자열) 을 할당함

* Go 에서는 할당되는 값을 보고 그타입을 추론하는 기능이 자주 사용됨

아래코드는 i는 정수형으로 1이 할당되고 s는 문자열로 Hi가 할당됨
```Go
var i = 1
var s = "Hi"
```

* 변수를 선언하는 또 다른 방식은 ```:=```를 사용하는 것이다
    * ```var i = 1```을 쓰는 대신 ```i := 1```이라고 var를 생량하고 사용이 가능함
    * 하지만 이 표현은 함수 내에서만 사용이 가능하며 함수 밖에서는 var를 사용해야함

* Go에서 변수와 상수는 함수 밖에서도 사용 가능함

## 상수
* 상수는 Go 키워드 ```const```를 사용하여 선언함
    * const 키워드 뒤에 상수명을 적고, 그뒤에 상수타입, 그리고 상수값을 할당함

```Go
const c int = 10
const s string = "Hi"
```

* 상수도 할당되는 값을 보고 그 타입을 추론하는 기능이 사용 가능함

* 여러 개의 상수들 묶어서 지정할수 있는데 ```( ) 괄호``` 안에 상수들을 나열하여 사용 가능함

```Go
const (
    Hello = "Hello"
    World = "World"
)
```

## Go 키워드
* Go 프로그래밍 언어는 아래와 같은 25개의 예약 키워드를 가짐
    * Go키워드들은 변수명, 상수명, 함수명, 등의 identifier로 사용할수 없음
```Go
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var
```

## Go 데이터 타입
1. 불린 타입 : bool
2. 문자열 타입 : string (string은 한번 생성되면 수정될 수 없는 Immutable 타입)
3. 정수형 타입 : int int8 int13 int32 int64 uint uint8 uint16 uint32 uint64 uintptr
4. Float 및 복소수 타입 : float32 float64 complex64 complex128
5. 기타 타입 : byte (unit8과 동일하며 바이트 코드에 사용) rune (int32와 동일하며 유니코드 코드포인트에 사용)

## 문자열
* 문자열 리터럴은 ```' '``` 혹은 ```" "```를 사용하여 표현할 수 있음
1. ```' '```로 둘러 싸인 문자열은 Raw String Siteral 이라 부르는데, 이 안에 있는 문자열은 별도로 해석되지 않고 Raw String 그대로의 값을 가짐
2. ```" "```로 둘러싸인 문자열은 Interpreted String Literal 이라 부르는데, 복수 라인에 걸쳐 쓸 수 없으며, 인용 부호 안의 Escape 문자열들은 특별한 의미로 해석된다

## 데이터 타입 변환
* 하나의 데이터 타입에서 다른 데이터 타입으로 변환하기 위해서는 ```T(v)```와 같이 표현하고 이를 Type Conversion 이라 부르는데, 여기서 T는 변환하고자 하는 타입을 표시하고, v는 변환될 값을 지정한 것이다
* Go에서 타입간 변환은 명시적으로 지정해 주어야 

## 연산자
1. 산술연산자
    * 산술연산자는 사칙연산자(+, -, *, / , %)와 증감연산자(++, --)를 사용함
2. 관계연산자
    * 관계연산자는 서로의 크기를 비교하거나 동일함을 체크하는데 사용된다 (==, !=, <, >, >=, <=)
3. 논리연산자
    * 논리연산자는 AND, OR, NOT을 표현하는데 사용됨 (&&, ||, !)
4. Bitwise연산자
    * Bitwise연산자는 비트단위 연산을 위해 사용되는데, 바이너리 AND, OR, XOR와 바이너리 쉬프트 연산자가 있음 (<<, >>)
5. 할당연산자
    * 할당연산자는 값을 할당하는 = 연산자 외에 사칙연산, 비트연산을 축약한 +=, &=, <<= 같은 연산자들도 있음
6. 포인터연산자
* 포인터연산자는 & 혹은 * 를 사용하여 해당 변수의 주소를 얻어내거나 이를 반대로 Dereference 할 때 사용함
* Go는 포인터연산자를 제공하지만 포인터 산술 즉, 포인터에 더하고 빼는 기능은 제공하지 않음

## 조건문
1. if 문
* GO 의 if 조건문은 조건식을 ```괄호 ( )```로 둘러 싸지 않아도 된다
* 조건 블럭 시작 브레이스 ```{```를 반드시 if문과 같은 라인에 두어야 한다
* if문의 조건식은 반드시 Boolean 식으로 표현되어야 한다
* else if 문 또한 사용이 가능, if문과 같은 규칙을 지님
* if문 조건식을 사용하기전에 간단한 문장을 함께 실행할수 있음 
    * 이 방식은 switch문, for문 등 Go의 여러 문법에서 사용이 가능함
```Go
if val := i * 2; val < max {
    println(val)
}
 
// 아래 처럼 사용하면 Scope 벗어나 에러
val++
```

2. Switch 문
* 다른 언어들과 비슷하게 switch 문 뒤에 하나의 변수를 지정하고 case 문에 해당 변수가 가질수 있는 값들을 지정하면 됨
* 복수개의 case 값들이 있을 경우는 콤마를 써서 나열 가능
* 다른 언어의 case문은 break를 쓰지 않는 한 다음 case로 이동하지만, Go는 다음 case로 가지 않음
* 다른 언어의 switch는 일반적으로 변수의 값을 기준으로 case로 분기하지만, Go는 기 변수의 Type에 따라 case로 분기할 수 있음
```Go
switch v.(type) {
case int:
    println("int")
case bool:
    println("bool")
case string:
    println("string")
default:
    println("unknown")
}   
```
* 다른언어처럼 계속 다음 case문 코드 블럭들을 실행하게 하려면 fallthrough 문을 명시해 주면됨

## 반복문
1. for문
* Go는 반복문에 for 하나 밖에 없다
* for 또한 ```괄호 ( )```를 생략함
    * 괄호를 쓰면 에러가 남

2. for문 조건식만 쓰는 for 루프
* Go에서 for 루프는 초기값과 증감식을 생략하고 조건식만 사용 가능함, 다른 언어의 while 루프와 같은 느낌

3. for문 무한루프
* 무한루프를 만들려면 초기값 조건식 증감 모두를 생략하면 됨

4. for range문
* for range 문은 컬렉션으로 부터 한 요소씩 가져와 차례로 for 블럭의 문장들을 실행함, 다른 언어의 foreach와 비슷
* for range문은 ```for 인덱스, 요소값 := range 컬렉션``` 같이 for 루프를 구성하는데, range 키워드 다음의 컬렉션으로부터 하나씩 요소를 리턴해서 그 요소의 위치인덱스와 값을 for 키워드 다음의 2개의 변수에 각각 할당한다

5. break, continue, goto문
* 경우에 따라 for 루프내에서 즉시 빠져나올 필요가 있는데 이때 break문을 사용함
* for 루프 중간에서 나머지 문장들을 실행하지 않고 for 루프 시작부분으로 바로 가려면 continue문을 사용
* 임의의 문장으로 이동하기 위해서 goto문을 사용
* break문은 보통 단독으로 사용되지만, 경우에 따라 break레이블 과 같이 사용하여 지정된 레이블로 이동할 수도 있다

## 함수
1. 함수
* Go에서 함수는 func 키워드를 사용하여 정의함
    * func 뒤에 함수명을 적고 ```괄호 ( )``` 안에 그 함수에 전달하는 파라미터들을 적게됨
* 함수 파라미터는 0개 이상 사용할 수 있는데, 각 파라미터는 파라미터명 뒤에 파라미터 타입을 적어서 정의함
* 함수의 리턴타입은 함수의 파라미터 괄호 뒤에 적게됨
* 함수는 패키지 안에 정의되며 호출되는 함수가 호출하는 함수의 반드시 앞에 위치해야 할 필요는 없음

2. Pass By Reference
* Go에서 파라미터를 전달하는 방식은 Pass By Reference와 Pass By Value로 나뉨   
    1. Pass By Value
    * Pass By Value 는 파라미터의 값이 함수 내에서 변경되어도 호출함수 에서는 변수의 값에 변함이 없는 방식이다
    2. Pass By Reference
    * 변수 앞에 ```&```부호를 붙이면 변수의 주소를 표시하게 됨 이 용법을 사용하면 함수에 변수의 값을 복사하지 않고 변수의 주소를 전달하게 됨
    * 주소 데이터를 사용하기 위해서는 변수명 앞에 ```*```부호를 붙이면 됨

3. Variadic Function (가변인자함수)
* 함수에 고정된 수의 파라미터들을 전달하지 않고 다양한 숫자의 파라미터를 전달하고자 할 때 가변 파라미터를 나타내는 ```...```을 사용한다
* 가변 파라미터를 갖는 함수를 호출할 때는 0개, 1개, 2개, 혹은 n개 등의 동일타입 파라미터를 전달할 수 있음
* 가변 파라미터를 받아들이는 함수를 가변인자함수 라고 함

4. 함수 리턴값
* Go 프로그래밍 언어에서 함수는 리턴값이 없을 수도, 리턴값이 하나 일 수도, 또는 리턴값이 복수 개일 수도 있음
* Go언어는 또한 Named Return Parameter 라는 기능을 제공하는데, 이는 리턴되는 값들을 리턴 파라미터들에 할당할 수 있는 기능임
* 값을 리턴하기 위해 함수내에서 return 키워드를 사용함
* Go에서 복수 개의 값을 리턴하기 위해서는 해당 리턴 타입들을 ```괄호 ( )```안에 적어 줌
* Go에서 Named Return Parameter들에 리턴값들을 할당하여 리턴할 수 있는데, 이는 리턴되는 값들이 여러 개일 때, 코드 가독성을 높이는 장점이 있음
    * 리턴되는 값이 있을 경우에는 빈 return 문을 반드시 써 주어야 함 (생략시 에러 발생)

## 익명함수
1. 익명함수
* 함수명을 갖지 않는 함수를 익명함수 라고 부름
* 일반적으로 익명함수는 그 함수 전체를 변수에 할당 하거나 다른 함수의 파라미터에 직접 정의되어 사용되곤 함
* 익명 함수가 변수에 할당된 이후에는 변수명이 함수명과 같이 취급되며 ```변수명(파라미터)```형식으로 함수를 호출할 수 있음

2. 일급함수
* GO 프로그래밍 언어에서 함수는 일급함수로서 Go 의 기본타입과 동일하게 취급되며, 따라서 다른 함수의 파라미터로 전달하거나 다른 함수의 리턴값으로도 사용될수 있다
* 함수의 입력 파라미터나 리턴 파라미터로서 함수 자체가 사용될 수 있음
* 함수를 다른 함수의 파라미터로 전달하기 위해서는 익명함수를 변수에 할당한 후 이 변수를 전달하는 방법과 직접 다른 함수호출 파라미터에 함수를 적는 방법이 있음

3. type문을 사용한 함수 원형 정의
* type 문은 구조체, 인터페이스 등 Custom Type을 정의하기 위해 사용됨
* type문은 또한 함수 원형을 정의하는데 사용될 수 있음
* 함수의 원형을 정의하고 함수를 타 메서드에 전달하고 리턴받는 기능을 타 언어에서 흔히 델리게이트라 부르는데 GO는 이 기능을 제공함

## 클로저
* Go 언어에서 함수는 Closure로서 사용될 수도 있음
    * Closure는 함수 바깥에 있는 변수를 참조하는 함수값을 일컫는데, 이때의 함수는 바깥의 변수를 마치 함수 안으로 끌어들인 듯이 그 변수를 읽거나 쓸 수 있게 됨

## 배열
1. 배열
* 배열은 연속적인 메모리 공간에 동일한 타입의 데이터를 순서적으로ㅓ 저장하는 자료구조
* 배열의 선언은 ```var 변수명 [배열크기] 데이터타입``` 과 같이 선언하는데, 배열 크기를 데이터 타입 앞에 써 주는 것이 다른언어와 차이점임
*GO에서 배열의 배열크기는 Type을 구성하는 한 요소이다, 즉 ```[3]int``` 와 ```[5]int```는 서로 다른 타입으로 인식됨

2. 배열의 초기화
* 배열을 정의할때 초기값을 설정할 수도 있음
* 초기값은 ```[배열크기] 데이터타입```뒤에 ```{ }```괄호를 두고 초기값을 순서대로 적으면 됨초기화 과정에서 ```[...]```를 사용하여 배열크기를 생략하면 자동으로 초기화 요소 숫자만큼 배열크기가 정해짐

3. 다배열 배열
* Go 언어는 다차원 배열을 지원함
* 다차원 배열은 배열 크기 부분을 복수 개로 설정하여 선언함

4. 다차원 배열의 초기화
* 다차원 배열의 초기화는 단차원 배열의 초기화와 비슷함, 다만 다차원이므로 배열 초기값 안에 다시 배열값을 넣는 형태를 띰

## 슬라이스
1. 슬라이스(Slice)
* Go 배열은 고정된 배열크기 안에 동일한 타입의 데이터를 연속정으로 저장하지만 배열의 크기를 동적으로 증가시키거나 부분 배열을 발췌하는 등의 기능을 가지고 있지 않음
* Go Slice는 내부적으로 배열에 기초하여 만들어 졌지만 배열의 이런 제약점들을 넘어 개발자에게 편리하고 유용한 기능들을 제공함
* 슬라이스는 배열과 달리 고정된 크기를 미리 지정하지 않을 수 있고 차후 그 크기를 동적으로 변경할 수도 있음
* Go Slice 선언은 배열을 선언하듯이 ```var v[ ]T```처럼 선언하는데 배열과 달리 크기를 지정하지 않음
* Slice를 생성하는 또 다른 방법으로 Go의 내장함수 ```make( )```함수를 이용할 수 있음
* make( ) 함수로 슬라이스를 생성하면 개발자가 슬라이스의 길이와 용량을 임의로 지정할 수 있는 장점이 있음
* make 함수의 첫번째 파라미터에 생성할 슬라이스 타입을 지정, 두번째는 슬라이스의 길이, 세번째는 내부 배열의 최대 길이 를 지정하면 모든 요소가 Zero value 인 슬라이스를 만들게 됨
    * 만약 세번째 값을 셍략시 두번째 값과 같은값을 가짐

2. 부분 슬라이스
* 슬라이스에서 일부를 발췌하여 부분 슬라이스를 만들 수 있음
* 부분 슬라이스는 ```슬라이스[처음인덱스:마지막인덱스]```형식으로 만듬
* 슬라이스 인덱스는 처음/마지막 둘 중 하나 혹은 둘 다를 생략할 수도 있음, 처음 인덱스가 생략되면 0이, 마지막 인덱스가 생략되면 그 슬라이스의 마지막 인덱스가 자동 대입됨

3. 슬라이스 추가, 병합 과 복사
* 슬라이스는 자유롭게 새로운 요소를 추가할 수 있음
* 슬라이스에 새로운 요소를 추가하기 위해서는 GO 내장함수인 ```append()```를 사용함
    * append()의 첫 파라미터는 슬라이스 객체이고, 두번째는 추가할 요소의 값임 또한 여러 개의 요소 값들을 한꺼번에 추가하기 위해서는 append() 두번째 파라미터 뒤에 계속하여 값을 추가할 수 있음
* 내장함수 append()가 슬라이스에 데이터를 추가할 때, 내부적으로 슬라이스 용량이 아직 남아 있는 경우는 그 용량 내에서 슬라이스의 길이를 변경하여 데이터를 추가하고, 용량을 초과하는 경우 현재 용량의 2배에 해당하는 새로운 Underlying array를 생성하고 기존 배열 값들을 모두 새 배열에 복제한 후 다시 슬라이스를 할당
* 한 슬라이스를 다른 슬라이스 뒤에 병합하기 위해서는 아래 예제와 같이 ```append( )```를 사용함 
    * append 함수에서는 2개의 슬라이스를 파라미터로 갖는데, 처음 슬라이스 뒤에 두번째 파라미터의 슬라이스를 추가하게 됨
    * 한가지 주의할 것은 두번째 슬라이스 뒤에 ```...```을 붙인다는 것인데 이는 해당 슬라이스의 컬렉션을 표현하는 것으로 두번째 슬라이스의 모든 요소들의 집합을 나타낸다
* Go 슬라이스는 내장함수 ```copy( )```를 사용하여 한 슬라이스를 다른 슬라이스로 복사할 수도 있음

5. 슬라이스의 내부구조
* 슬라이스는 내부적으로 사용하는 배열의 부분 영역인 세그먼트에 대한 메타 정보를 가지고 있음
* 슬라이스는 크게 3개의 필드로 구성되어 있는데, 첫째 필드는 내부적으로 사용하는 배열에 대한 포인터 정보이고, 두번째는 세그먼트의 길이를, 그리고 마지막으로 세번째는 세그먼트의 최대 용량 임
* 처음 슬라이스가 생성될 때, 만약 길이와 용량이 지정되었다면 내부적으로 용량만큼의 배열을 생성하고, 슬라이스 첫번째 필드에 그 배열의 처음 메모리 위치를 지정한다 그리고 두번째 길이 필드는 지정된 길이를 갖게되고, 세번째 용량 필드는 전체 배열의 크기를 가짐

## 맵
1. Map 개요
* Map은 키에 대응하는 값을 신속히 찾는 해시테이블을 구현한 자료구조임
* GO 언어는 Map 타입을 내장하고 있고 ```map[Key타입]Value타입```과 같이 선언할 수 있음
* map을 초기화하기 위해 make() 함수를 사용할 수 있음
* make() 함수의 첫번째 파라미터로 map 키워드와 [키타입]값타입 을 지정하는데, 이때의 make() 함수는 해시테이블 자료구조를 메모리에 생성하고 그 메모리를 가리키는 map value를 리턴함
* map은 make 뿐만 아니라 리터럴을 사용해 초기화할 수도 있음
    * 리터럴 초기화는 ```map[Key타입]Value타입 {key:value}```와 같이 Map 타입 뒤 {} 괄호 안에 키:ㄱ밧 들을 열거하면 됨

2. Map 사용
* 처음 map이 make() 함수에 의해 초기화 되었을 때는 아무 데이터가 없는 상태임, 이때 새로운 데이터를 추가하기 위해서는 ```map변수키[키] = 값```과 같이 해당 키에 그 값을 할당하면 됨
*map 에서 특정 키에 대해 값을 읽을 때는 ```map변수[키]```를 읽으면 됨
* map 에서 특정키와 그 값을 삭제하기 위해서는 delete()함수를 사용함

3. Map 키 체크
* map을 사용하는 경우 종종 map안에 특정 키가 존재하는지를 체크할 필요가 있음 
* 위 상황을 위해 Go에선 ```map변수[키]``` 읽기를 수행할 때 2개의 리턴값을 리턴함
    * 첫번째는 키에 상용하는 값이고, 두번째는 그 키가 존재하는지 아닌지를 나타내는 bool 값임

4. for 루프를 사용한 Map 열거
* map이 갖고 있는 모든 요소들을 출력하기 위해 for range 루프를 사용할 수 있음
* map 컬렉션에 for range를 사용하면 map 키와 map 값 2개의 데이터를 리턴함