## 즉시로딩
```FetchType.EAGER```

* 연관된 엔티티를 즉시 조회한다
* 즉시로딩을 사용하려면 @ManyToOne의 fetch 속성을 ```FetchType.EAGER```로 지정한다
* ```@ManyToOne(fetch = FetchType.EAGER)```
* JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다, 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다

### 즉시로딩 주의 사항
1. 컬렉션을 하나 이상 즉시 로딩하는 것을 권장하지 않는다
    * 컬렉션을 조인한다는 것은 데이터베이스 테이블로 보면 일대다 조인이다
    * ex) A 테이블을 N, M 두 테이블과 일대다 조인하면 SQL 실행 결과가 N * M이 되서 너무 많은 데이터를 반환할 수 있고 결과적으로 애플리케이션 성능이 저하될 수 있다
    * 따라서 2개 이상의 컬렉션을 즉시 로딩으로 설정하는 것은 권장되지 않는다

2. 컬렉션 즉시 로딩은 항상 외부조인을 사용한다
    * 다대일 관계인 회원 테이블과 팀 테이블에 조인할 때 회원 테이블의 외래키에 not null 제약조건을 걸어두면 모든 회원은 팀 소속이므로 항상 내부조인을 사용해도 된다
    * 반대로 팀 테이블에서 회원 테이블로 일대다 관계를 조인할 때 회원이 한명 도 없는 팀을 내부 조인하면 팀까지 조회되지 않는 문제가 발생한다, 데이터베이스 제약조건으로 이런 상황을 막을수 없게 됨
    * 따라서 JPA는 일대다 관계를 즉시 로딩할 때 항상 외부조인을 사용한다

## 지연로딩
```FetchType.LAZY```

* 연관된 엔티티를 프록시로 조회한다, 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다
* 지연 로딩을 사용하려면 @ManyToOne의 fetch속성을 ```FetchType.LAZY```로 지정한다
* ```@ManyToOne(fetch = FetchType.LAZY)```
* 조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다, 따라서 영속성 컨텍스트에 이미 로딩되어 있으면 프록시 객체가 아닌 실제 객체(엔티티)를 사용한다