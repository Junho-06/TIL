# **객체지향 프로그래밍**
> **Python 객체지향 프로그래밍을 더 알아보기 위해 공부한 내용**
---
* __객체지향 프로그래밍 이란?__
    * 프로그램을 여러 개의 독립된 객체들과 그 객체들 간의 상호작용으로 파악하는 프로그래밍 접근법이다.
    * 프로그램을 객체들 간의 소통으로 바라보는 것.
---
* __객체 지향 프로그래밍으로 프로그램을 만들려면?__
    * 프로그램에 어떤 객체들이 필요할지 정한다.
    * 객체들의 속성과 행동을 정한다.
    * 객체들이 서로 어떻게 소통할지 정한다.
---
* __“파이썬은 객체 지향적 프로그래밍 언어이다, 파이썬의 모든 것은 오브젝트이다, 문자열, 리스트, 함수, 심지어 모듈 또한 오브젝트이다__
    * 그럼 오브젝트란 무엇일까
        * 속성과 같은 여러가지의 데이터와 함수(메서드) 를 포함한 하나의 데이터 구조를 말한다 파이썬에서 이 오브젝트 들은 변수에 할당 될수도 있고, 함수의 인자로 전달될 수도 있는 퍼스트 클래스 오브젝트 이다
---
## **클래스와 인스턴스**
* 클래스는 우리말로 정의하기 쉽지 않지만 ```'부류'``` 라는 의미가 어울린다
* Pyton 의 클래스를 만들기 위해서는 ```class 클래스이름:``` 형식으로 시작하고 그 다음부터 클래스의 성질이나 행동을 정의해준다
* 클래스 내부에 정의된 ```함수```는 ```'메서드'``` 라고 부른다
* 클래스의 인스턴스를 만들기 위해서는 ```인스턴스명 = 클래스이름()``` 으로 만들수 있다, 그렇게 만들어진 인스턴스를 ```'객체'``` 라고 부른다 
* 어떤 객체의 메서드를 사용할때 에는 ```객체.메서드``` 형식으로 사용한다
---
## **클래스 네임스페이스**
* 클래스와 인스턴스의 차이를 정확히 이해하는것은 중요함
    * 이를 위해서는 네임스페이스 라는 개념을 알아야함
* 네임스페이스 라는 것은 변수가 객체를 바인딩할 때 그 둘사이의 관계를 저장하고 있는 공간을 의미함
* ex) a=2라고 했을 때 a라는 변수가 2라는 객체가 저장된 주소를 가지고 있는데 그러한 연결 관계가 저장된 공간이 바로 __네임스페이스__ 이다
* 파이썬의 클래스는 새로운 타입(객체)을 정의하기 위해 사용되며, 모듈과 마찬가지로 하나의 네임스페이스를 가짐
```python
class Stock:
    makret = "kospi"
dir()
# 파이썬 IDE의 dir 내장함수를 호출하면 Stock클래스의 이름이 포함된것을 확인할수 있다
#dir 내장함수의 결과값에 Stock 클래스가 들어있기 때문에 Stock을 입력해도 오류가 발생하지 않습니다. 그러나 Stock1이라는 이름은 존재하지 않기 때문에 입력하면 오류가 발생 합니다
```
* 파이썬 에서는 클래스가 정의되면 하나의 독립적인 네임스페이스가 생성됨, 클래스 내에 정의된 변수나 메서드는 해당 네임스페이스 안에 파이썬 딕셔너리 타입으로 저장됨
* 파이썬은 인스턴스를 생성하면 인스턴스별로 별도의 네임스페이스를 유지함
* 인스턴스의 네임스페이스는 최초 생성시 비어있음, 인스턴스에 변수를 추가 해주면 키:값 쌍이 추가된다
* 네임스페이스에 아무것도 존재하지 않는 인스턴스에 접근 하면 클래스의 네임스페이스의 내용을 받아오기 때문이다
* 인스턴스의 변수에 접근하면 파이썬은 먼저 인스턴스의 네임스페이스에서 해당 변수가 존재하는지 찾고, 존재하지 않는다면 클래스의 네임스페이스로 가서 다시 변수를 찾는다
    * 만약 클래스에도 존재하지 않는다면 오류가 일어남
---
## **변수와 메서드**
```python
class example:
    age = 17;
    gender = "남";

    def sayHello(self):
        print("Hello")

# example 라는 클래스가 가지고 있는 나이, 성별은 변수로 나타내었고 Hello 라고 인사하는 행동은 sayHello 라는 메서드로 나타내었음
```
* 위 코드를 (모듈이름).py 확장자로 저장한 후에 ```import 모듈이름``` 으로 모듈을 임포트 한 후에 example클래스의 객체를 만들기 위해서는 ```객체이름 = 모듈이름.클래스이름()```을 사용
```python
example_human = exmaple_module.example()
# 이렇게 만들어진 객체는 클래스에 해당하는 자질을 모두 가지고 있을 것이다.👇
example_human.sayHello()
# 출력 결과 : Hello
```
* 객체는 클래스에서 정의해준 변수와 메서드를 그대로 갖게 된다
---
## **클래스 변수와 인스턴스 변수**
```python
class Account:
# Account 클래스에는 num_accounts와 self.name이라는 두 변수가 있다
    num_accounts = 0
    # num_accounts처럼 클래스 내부에 선언된 변수를 '클래스 변수'라고 함
    def __init__(self, name):
        self.name = name
        # self.name과 같이 self가 붙어있는 변수를 '인스턴스 변수' 라고 함
        Account.num_accounts += 1
    def __del__(self):
        Account.num_accounts -= 1
# 클래스 변수는 Account 클래스의 네임스페이스에 위치하며, self.name과 같은 인스턴스 변수는 인스턴스의 네임스페이스에 위치함
```
* 인스턴스 변수 접근법 : ```self.인스턴스변수```
* 클래스 변수 접근법 : ```클래스.클래스변수```
* 클래스 변수와 인스턴스 변수 차이점  
    |차이점|클래스변수|인스턴스변수|
    |:---:|:---|:---|
    |사용구분|모든인스턴스에서 공유하는 값|그 인스턴스만 사용하는 값|
    |정의하는 곳|클래스 정의문 바로 아래에 대입된 변수|함수 정의문 바로 아래에 대입된 self의 속성|
    |클래스 객체로부터 참고|가능|불가능|
    |인스턴스 객체로부터 참고|가능|가능|
    |변경|모든 인스턴스가 변경|그 인스턴스의 속성만 변경|
---
## **self**
```python
class example:
    age = 17;
    gender = "남";

    def sayHello(self):
        print("Hello")

example_human1 = exmaple_module.example()
example_human2 = exmaple_module.example()

example_human1.sayHello()
example_human2.sayHello()
```
* 위의 코드에서 주의할점은 메서드를 정의할떄와 사용할때의 차이 이다
* example 클래스에서 메서드를 정의할 때는 ```def sayHello(self):```처럼 self라는 인자를 받았지만 example_human 객체의 메서드를 호출할 때는 그냥 sayHello()라고 했다는 점이다
* self라는 것은 그 클래스의 객체를 가리키는데, example_human1과 example_human2가 똑같은 sayHello 메서드를 가지기 때문에 서로 구별하기 위해서 사용하는 것이다
* 한마디로 메서드를 정의할 때는 항상 self라는 인자를 써주는것이다
---
## **상속**
* 상속이란 어떤 클래스가 다른 클래스의 성질을 물려받는 것을 말한다
* 어떤 클래스를 만들 때 처음부터 모든 것을 새로 만들 필요 없이, 핵심적인 성질을 갖고 있는 다른 클래스로부터 상속을 받아서 조금만 손을 보게 되면 클래스를 만들수있음  
ex 👇
```python
class Person:
    eyes = 2
    nose = 1
    mouth = 1
    ears = 2
    arms = 2
    legs = 2

    def eat(self):
        print('냠냠')

    def sleep(self):
        print('쿨쿨')

    def talk(self):
        print('주절주절')
# 위의 Person이라는 클래스는 보통 사람을 나타낸 클래스 이다
# 여기서 학생이라는 클래스를 만들어 보자 학생은 사람이기 때문에
# 사람이 가지는 여러 성질, 행동은 모두 가지고 있을 것이다
# 거기에 학생의 몇가지 특성만 추가하면 학생이 될것이다
# 이럴때 사용하는것이 바로 상속이다
# 아래의 코드가 '상속' 이다 👇 
class Student(Person):
    def study(self):
        print("열공열공")
# 위으 Student 클래스는 Person 이라는 클래스를 상속 받았다
# Student클래스에 Person의 내용을 다시 적지 않고도 Person의 성질들을 모두 물려 받은 것이다
```
* 굳이 상속을 받지않고 스크립트를 복사해서 붙이는것도 가능하긴 하다
    * 하지만 나중에 Person 클래스나 Student 클래스에 추가하고싶은 내용이 있다면 Person 클래스와 Student 클래스를 각각 수정해야 된다
---
## **다중상속**
* ```클래스명.__mro__``` 를 치게되면 클래스의 메서드 탐색 순서가 나옴
* MRO = ```자식클래스 -> 부모클래스(먼저 상속받은 순서대로 우선순위가 높음) -> (부모클래스가 상속을 받았을 경우 그 부모 클래스) -> 최상위 object 클래스 순서로 메소드가 호출 됨```
* 다중 상속은 여러 기반 클래스로부터 상속을 받아서 파생 클래스를 만드는 방법이다. 다음과 같이 클래스를 만들 때 ( )(괄호) 안에 클래스 이름을 ,(콤마)로 구분해서 넣는다.
```python
class 기반클래스이름1:
    코드

class 기반클래스이름2:
    코드

class 파생클래스이름(기반클래스이름1, 기반클래스이름2):
    코드
```
* __super__
    * ```super().메서드이름()```
    * 다중 상속에서 클래스는 여러 클래스의 속성과 메서드를 상속 할 수 있다. 즉, 클래스에 여러 슈퍼 클래스가 있습니다. super()함수는 유용하며 주로 다중 상속의 경우에 사용됨
    * super() 함수는 클래스에서 재정의 된 상속 된 메서드에 엑세스 함, super()함수는 다음 상위 클래스 또는 슈퍼 클래스의 함수를 액세스하기 위해 다중 상속이 있는 하위 클래스에서 사용됨
    * super() 함수는 MRO를 사용하여 다음 상위 클래스를 결정함
    * 클래스가 단일 상속 클래스 인 경우 super() 함수는 이름을 명식적으로 사용하지 않고 부모 클래스의 메서드를 사용하는데 유용함
* __다이아몬드 상속__  

![다이아몬드 상속](https://velog.velcdn.com/images%2Fyeonu%2Fpost%2F1ee0cd1e-01a0-49e9-bfbb-ebe7addd7090%2Fdd.png)
* 위와 같은 사진이 다이아몬드 상속의 구조이다
* 코드로 보면 아래와 같다
```python
class A:
    def greeting(self):
        print('안녕하세요. A입니다.')

class B(A):
    def greeting(self):
        print('안녕하세요. B입니다.')

class C(A):
    def greeting(self):
        print('안녕하세요. C입니다.')

class D(B, C): # 왼쪽부터 실행
    pass

x = D()
x.greeting()

# 출력 : 안녕하세요. B입니다.
```
* 다이아몬드 상속에서 위와 같은 결과가 나오는 이유는 파이썬의 MRO(메서드 탐색 순서)를 제공하기 때문이다
* 다이아몬드 상속에서 super( ) 를 사용하여도 MRO에 의해 적용되지 않음
---
## **메서드 오버라이딩**
* 오버라이딩은 부모 클래스의 메서드를, 자식 클래스에서 재정의 하여 사용하는 것을 의미함
* ex) 부모클래스에서 add()라는 메서드는 2개의 인자밖에 더할 수 없지만, 자식 클래스의 add() 메소드는 오버라이딩되어 3가지의 인자까지 받도록 재정의 할 수 있음
```python
class ParentEx():
    def __init__(self):
        self.value = 5

    def get_value(self):
        return self.value


class ChildEx(ParentEx):
    def get_value(self):
        return self.value * 10
# 메소드 변경 => 메소드 오버라이딩

c = ChildEx()
print("Ex >", c.get_value())
# 출력 : Ex > 50
```
---
## **객체 속의 객체**
* 코끼리를 냉장고에 넣는 방법으로 프로그램을 만들어 보자  
* 1번, 냉장고 문을 연다.
* 2번, 코끼리를 넣는다.
* 3번, 냉장고 문을 닫는다.   
```python
# fridge.py

class Fridge:
    def __init__(self):
        self.isOpened = False
        self.foods = []
    
    def open(self):
        self.isOpened = True
        print ('냉장고 문을 열었어요')
    
    def put(self, thing):
        if self.isOpened:
            self.foods.append(thing)
            print ('냉장고 속에 음식이 들어갔네')
        else:
            print ('냉장고 문이 닫혀있어서 못넣겠어요')
    
    def close(self):
        self.isOpened = False
        print ('냉장고 문을 닫았어요')

class Food:
    pass
```
* 위 코드와 같이 냉장고와 음식 클래스를 갖고있는 fridge.py 라는 모듈을 만들었다
* 냉장고 클래스에는 문이 열려있는지를 나타내는 isOpened라는 Boolean 자료형을 받는 변수와 냉장고 안에 들어있는 음식들의 리스트인 foods가 있다
* 냉장고 문을 열고, 음식을 집어넣고, 문을 닫는 메서드도 각각 존재함
* 음식에 대해서는 별로 쓸것이 없기 때문에 쓸것이 없을때 쓰는 ```pass```를 써주었다, 즉 클래스의 속이 비어있는 것이다  

__냉장고에 코끼리를 넣어보자__
```python
import fridge
f = fridge.Fridge()
# 냉장고 클래스의 객체로 'f' 를 만듬
apple = fridge.Food()
elephant = fridge.Food()
# 음식 클래스의 객체로 'apple', 'elephant' 를 만듬
f.open()
# 출력 : 냉장고 문을 열었어요
f.put(apple)
# 츨력 : 냉장고 속에 음식이 들어갔네
f.put(elephant)
# 출력 : 냉장고 속에 음식이 들어갔네
f.foods
# 반환 : [<fridge.Food instance at 007924AC>, <fridge.Food instance at 0079153C>]

# Food 클래스의 인스턴스가 두개가 들어있다고 나온다 인스턴스와 객체는 비슷한 의미이다
# 냉장고 객체는 foods라는 리스트를 갖고 있고, foods리스트는 음식 클래스의 사과와 코끼리 객체를 가지고 있다
# 한마디로 냉장고 객체는 다른 객체들을 가지고 있다고 할수 있다
```
* 위의 내용 처럼 객체는 또 다른 객체를 포함할 수도 있다
    * 객체지향 프포그래밍에서 이런 것을 composition(합성, 복합)  이라고 하고, 'has-a' 관계 라고도 한다
---
## **특별한 메서드들**
* 메서드라는 것은 클래스를 만들면서 클래스 안에 내장한 함수를 말함, 만들어진 메서드를 사용하려면 ```객체.메서드()```와 같은 형식으로 호출  
> **```__init__```메서드**
```python
# bookstore.py

class Book:

    def setData(self, title, price, author):
        self.title = title
        self.price = price
        self.author = author

    def printData(self):
        print ('제목 : ', self.title)
        print ('가격 : ', self.price)
        print ('저자 : ', self.author)

    def __init__(self):
        print ('책 객체를 새로 만들었어요')
```
* 예시로 책 클래스를 갖는 bookstore.py라는 모듈을 만듬
* 책 클래스의 메서드로는 책 제목, 가격, 저자와 같은 자료들을 입력할 때 사용할 setData()와 이런 자료들을 출력해주는 printData()를 만들었음
* 그리고 중요한것은 ```__init__``` 메서드 이다, 이 메서드는 파이썬에서 특별하게 약속된 메서드 가운데 하나로, 초기화(initialize) 메서드 라고도 함
* 어떤 클래스의 객체가 만들어질 때 자동으로 호출되어서 그 객체가 갖게 될 여러 가지 성질을 정해주는 일을 함
* bookstore.py 모듈을 이용하여 책 클래스의 객체를 만들어보자
```python
import bookstore
b = bookstore.Book()
# 출력 : 책 객체를 새로 만들었어요
# 👆 Book() 해서 Book 객체를 만들자마자 초기화 메서드가 실행됨
```
* 나머지 setData와 printData 메서드들은 다음과 같이 사용하시면 됨
```python
b.setData('누가 내 치즈를 먹었을까', '300원', '미키')
b.printData()
# 출력 : 제목 :  누가 내 치즈를 먹었을까
# 출력 : 가격 :  300원
# 출력 : 저자 :  미키
```
* ```__init__```메서드를 사용해서 실제로 객체를 초기화 해보자
* bookstore.py 의 모듈 안에 ```__init__``` 메서드를 아래 코드처럼 수정했다고 하자
```python
 def __init__(self, title, price, author):
        self.setData(title, price, author)
        print ('책 객체를 새로 만들었어요')
```
* 객체를 생성시킬 때 제목, 가격, 저자를 인자로 받아서, setData 메서드에 넘겨주도록 함, 초기화 메서드에서 직접 변수를 다뤄도 상관없지만 setData 메서드를 미리 만들어뒀으니 이용을 하였음
* 이제는 책 객체를 만들 때는 아래 코드 처럼 세개의 인자를 넘겨 주어야 함
```python
reload(bookstore)
b2 = bookstore.Book('내가 먹었지롱', '200원', '미니')
# 출력 : 책 객체를 새로 만들었어요
```
* 초기화 메서드와 같은 것을 다른 객체지향 언어에서는 생성자(constructor) 라고 부름
> **```__del__```메서드**
* ```__init__```메서드 와 반대로 객체가 없어질 때 호출되는 메서드도 있음, 이런 것을 소멸자(destructor)라고 하며, 파이썬에서는 ```__del__```메서드 가 소멸자의 역할을 맡고있음
* del 문을 사용하면 객체를 없앨수 있음, 만들어둔 객체가 더 이상 필요가 없어지면 파이썬이 알아서 처리해주기도 함
* 어떤 객체가 없어지기 전에 뭔가 처리를 필요로 한다면 소멸자가 유용하게 쓰일 것이다, ```__del__``` 메서드의 작성은 다른 메서드와 똑같다
> **```__repr__```메서드**
* printData와 같은 메서드를 호출하는 대신, 파이썬의 기본문인 print문을 사용하여 책 제목을 찍어보자, 이런 일을 가능하게 하는것이 ```__repr__```메서드 이다
* 책 클래스에 아래코드 처럼 ```__repr__``` 메서드를 추가하자
```python
def __repr__(self):
    return self.title
```
* return 문을 사용하였다는것을 눈여겨 봐야함
* ```__repr__```메서드 는 '문자열'을 'return' 한다고 생각하면 된다
* 👇 아래 코드로 책방 모듈을 재적재 하고 새책을 만들고 테스트 해보자
```python
b3 = bookstore.Book('나두 좀 줘', '100원', '쥐벼룩')  
# 출력 : 책 객체를 새로 만들었어요 
print(b3)
# 출력 : 나두 좀 줘
```
> **```__add__```메서드**
* 예제로 세모, 네모, 동그라미 같은 도형을 만들어보자    
```python
# shape.py

class Shape:

    area = 0

    def __add__(self, other):
        return self.area + other.area
# 두 도형의 넓이를 더하는 __add__ 메서드를 만들었다
# 두 개의 객체 self와 other를 인자로 받아서 그 둘의 넓이를 더한 값을 돌려주는 일을 하도록 했지요.
```
```python
a = shape.Shape()
a.area = 20
b = shape.Shape()
b.area = 10
print(a + b)
# 출력 : 30
# 도형 a와 도형 b를 덧셈연산자(+)로 더했더니 두 도형의 넓이의 덧셈결과가 반환됨
```
* 위 코드에서 처럼 특별한 메서드를 사용해서 연산자가 하는 일을 정의하는 것을 연산자 중복(overload) 이라고 부른다
* 연산자 중복을 이용하면 사용자가 직접 만든 클래스의 객체에 대해서도 연산자를 쓸 수 있게 됨
* Shape 클래스에 ```__add__``` 메서드를 넣지 않고 객체 두 개를 더할수는 없다
* 아래 코드 처럼 덧셈 연산자 대신 ```__add__``` 메서드를 직접 호출해도 그 결과는 똑같다
```python
a.__add__(b)
# 출력 : 30
```
> **```__cmp__```메서드**
* 파이썬에서 제공하는 연산자 중복 메서드는 이외에도 많이 있다
* 두 객체를 비교하는 비교연산자를 쓸수있도록 해주는 ```__cmp__```를 알아보자
* Shape 클래스에 아래 코드 처럼 ```__cmp__```메서드를 추가하자
```python 
def __cmp__(self, other):
    if self.area < other.area :
        return -1
    elif self.area == other.area :
        return 0
    else :
        return 1
```
* 두 객체 self와 other를 비교해서 self가 크면 1을, other가 크면 -1을 돌려주고, 두 수가 같을 땐 0을 돌려주도록 했다
* 두 숫자를 비교하듯이 두 객체를 비교하면 된다, shape 모듈을 재적재 하고 새로운 객체들을 만들어서 각각 area값을 정해준다음 비교해보자
```python
a = shape.Shape()
a.area = 20
b = shape.Shape()
b.area = 10
if a > b:
    print("a가 더 넓음")
else:
    print("b가 더 넓음")
# 출력 : a가 더 넓음
```
---